# Week 02 — Shader Exercises and First Vibecoding

**Course:** Vibecoding GLSL Shaders | CalArts Program in Experimental Animation

## Where We Are

Students successfully ran the local shader server, completed several exercises, and used LLMs to "vibecode" original shaders. The class ended with a walk-around critique and informal gallery viewing of everyone's results.

## Lecture Notes

### 1. Administrative and Funding Notes: "Builder Club" Offer

- We looked at an "AI builder club" style program offering a stipend (roughly $1,300–$1,700) in exchange for organizing workshops, demos, and outreach on campus.
- Discussion focused on tradeoffs:
  - What you "give away" (time, visibility, role as a campus representative).
  - How public the involvement might be, and whether that creates unwanted spotlight.
  - Whether it could be framed as a student-led project rather than institutional advocacy.
- Conclusion: entirely personal; worth considering if you want funding, but be clear-eyed about responsibilities and visibility.

### 2. Tools for Today: Pick an LLM and Keep It Simple

**Goal:** start with free accounts to establish the workflow, then optionally move to Claude Code if credits land.

- **Recommended baseline:** a free ChatGPT account (or DeepSeek as an alternative).
- Practical notes from signup:
  - Use a school email if you want a clean separation from personal accounts.
  - Expect verification steps (email login, SMS code, profile setup).
  - Privacy policy was flagged as something to be aware of, even if we are not fully parsing it in class.
- **Strategy:** use free tools for learning the workflow; try to secure Claude credits for sustained semester use.

### 3. GitHub and Repositories: Getting the Course Code Locally

We reviewed why Git/GitHub matters: collaboration, version history, and keeping the same codebase across machines.

- **Repository:** Shader Playground (course codebase; created via vibecoding).
- Workflow goals:
  - Download or clone the repository so you can edit locally.
  - Run a lightweight dev server so shader edits update immediately.

### 4. Terminal Basics and Safety

We opened Terminal and covered a few "minimum viable" commands.

**Core ideas:**

- Terminal is powerful and unforgiving: no "Are you sure?" prompts.
- Safety warning: do not run destructive commands (example discussed: `rm -rf /`).

**Common controls:**

| Key | Action |
|-----|--------|
| `Ctrl+C` | Stop a running process |
| `Up arrow` | Scroll command history |
| `Tab` | Autocomplete paths and commands |
| `clear` | Clear the screen |

**Navigation and setup:**

| Command | What it does |
|---------|--------------|
| `cd` | Go to your home directory |
| `pwd` | Print current directory |
| `mkdir` | Make a new folder (we used `_CODE` as a central workspace) |
| `open .` | Open a Finder window for the current directory |

### 5. Clone the Repo into a Dedicated _CODE Folder

Standard pattern:

```bash
cd
mkdir _CODE        # if you don't already have it
cd _CODE
git clone <https GitHub repo URL>
```

Common issues and fixes:

- If `git clone` fails, confirm:
  - You copied the HTTPS URL (not SSH).
  - You are in the intended folder (`pwd`).
  - Git is installed and available.
- If you cloned into the wrong place, don't panic; just navigate or re-clone in the correct directory.

### 6. Installing Node and NPM Without Admin Privileges

We needed Node/NPM to run the local dev server. Some lab machines required user-local installs.

**Approach:** Ask the LLM: *"How do I install Node/NPM on macOS without admin privileges?"*

Common recommendation: **NVM** (Node Version Manager), installed in your user directory.

Typical flow:

1. Run the NVM install script.
2. Restart Terminal so your shell config is reloaded.
3. Install Node via NVM (example: `nvm install node`).

**Debugging practice (important habit):**

- If Terminal reports an error after restart:
  - Copy the error text.
  - Ask the LLM what it means and how to fix it.
  - Apply one change at a time, then restart Terminal and re-test.
- Shell config behavior:
  - `.zshrc` runs when a new Terminal session starts.
  - Lines beginning with `#` are comments (ignored by the shell).

### 7. Install Project Dependencies and Run the Dev Server

Once inside the repo folder:

```bash
npm install       # creates node_modules locally inside the project
npm run dev       # starts the dev server
```

Expected result:

- Terminal prints a local URL (usually `http://localhost:5173/`).
- Opening that URL in a browser shows the shader playground interface.
- When you edit shader files and save, the dev server hot-reloads and the browser updates.

### 8. Editing Shaders: Where the Exercise Files Live

We opened the project folder in a text editor (BBEdit, VS Code, Xcode all workable).

**Key path:** `src/shaders/exercises/`

Example: `src/shaders/exercises/ex1.frag`

**Concepts covered while editing:**

- **Comments:** In GLSL, `//` begins a comment (ignored by the compiler).
- **Color vectors:** Colors are expressed as a 3-component vector (R, G, B).
  - Values are floats from `0.0` to `1.0`, not 0–255.
  - White: `(1.0, 1.0, 1.0)` / Black: `(0.0, 0.0, 0.0)` / Red: `(1.0, 0.0, 0.0)` / Purple: `(1.0, 0.0, 1.0)`
- **Alpha/transparency:** A 4th value can represent opacity, but transparency only "reads" if there is something behind it.

### 9. Exercises Completed (Core Learning Goals)

The exercises were framed as **vocabulary-building**: learn just enough GLSL structure to ask for meaningful changes from an LLM.

Exercise themes:

- **Solid color shader** — Edit RGB values and observe immediate change.
- **Gradient shader** — Work with UV coordinates. Example change: switch gradient direction by using `uv.y` instead of `uv.x`.
  - Important UI note: you must be viewing the correct exercise page in the browser to see the corresponding shader update.
- **Animation examples** — We tested a pulsing shape (circle-like form) and discussed time-based oscillation: time-driven values often use periodic functions that smoothly cycle.

### 10. Recording Output: Exporting MP4s from the Browser

We used the built-in record feature in the shader interface.

**Workflow:**

1. Click the record circle in the upper-left corner to start recording.
2. Make adjustments / let an animation cycle.
3. Stop recording and download the video file.

Note: the recording captures the shader output, not the UI chrome, which makes it practical for editing workflows.

### 11. Vibecoding in Practice: Ask the Model for Targeted Fixes

We modeled a useful "LLM collaboration" pattern:

**Problem:** A circle becomes an oval when the browser window isn't square (aspect ratio distortion).

**Solution:** Ask the model for a GLSL fix that corrects for aspect ratio and preserves circular geometry regardless of window shape.

**Result:** The circle stayed circular across window sizes.

This is the **core vibecoding loop:**

1. Describe the observed behavior.
2. State the desired behavior precisely.
3. Ask for the smallest code change that achieves it.
4. Paste, test, iterate.

### 12. Closing: Informal Critique and "Gallery Walk"

- Once the server + editor workflow was working, students began vibecoding original shaders.
- Results were strong enough that the last part of class became a walk-around viewing session:
  - Looking over shoulders
  - Comparing aesthetics and parameter choices
  - Sharing quick fixes and prompt strategies
  - Celebrating the fact that everyone had a working toolchain

## Key Takeaways to Carry into Next Class

If you can:

1. Clone the repo
2. Install dependencies
3. Run `npm run dev`
4. Locate and edit the shader files

...then you have the entire production loop needed for the course.

- The point of the early exercises is not mastery; it is **vocabulary**: know what "UV," "vec3," "aspect ratio," "time," "oscillation," and "color space" mean well enough to ask for changes clearly.
- **Debugging is part of vibecoding:**
  - Copy errors
  - Ask the LLM what they mean
  - Apply one fix at a time
  - Restart and re-test
